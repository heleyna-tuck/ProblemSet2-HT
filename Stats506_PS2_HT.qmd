---
title: "Stats506_PS2"
author: "Heleyna Tucker"
format:
  html:
    embed-resources: true
editor: visual
---

# Problem 1 - Dice Game

Let's play a dice game. It costs \$2 to play. You roll a single 6-sided die.

-   On a roll of 2, 4, or 6, you win the amount on the roll (e.g. a roll of 4 wins \$4).

-   On a roll of 1, 3, or 5, you lose

We're going to implement this in different ways. Each function takes in as input the number of dice to roll, and each function returns your total winnings or loses. E.g.

play_dice(10) -\> \[1\] 4

play_dice(10) -\> \[1\] -6

## Part A:

i\) Version 1: Implement this game using a loop over the dice rolls.

```{r}
#' Function to play dice game
#'
#' @param rolls is a numberic entry for the number of rolls the user specifies
#'
#' @return total value according to dice role rules (even number rolled, add to total, odd number rolled, take away from total.)
#' @export
#'
#' @examples
play_dice1 <- function(rolls) {
  total <- -2*rolls
  for (i in 1:rolls){
    roll <- sample(1:6,1)
    if (roll %% 2 == 0){
      total <- total + roll
    }
    else{
      total <- total - roll
    }
  }
  return(total)
}
```

\*ii) Version 2: Implement this game using built-in R vectorized functions.

*How do I do this?* Not sure what it's asking me to do

```{r}
#' Function to play dice game using vectorized functions
#'
#' @param rolls is a numeric entry for the number of rolls the user specifies
#'
#' @return total amount of money the player has when the game is played (even number rolled, add to amount of money. Odd number rolled, take away. It takes 2 dollars to play so subtract that from total as well.)
#' @export
#'
#' @examples
play_dice2 <- function(rolls){
  total_rolls <- sample(1:6, rolls, replace = TRUE)
  for(i in (1:rolls)){
      if(total_rolls[i] %in% c(1,3,5)){
        total_rolls[i] = -total_rolls[i]
  }
  }
  total <- (sum(total_rolls) - (2*rolls))
  return(total)
}
```

Above is the game implemented with built-in R vectorized function sum()

iii\) Version 3: Implement this by collapsing the die rolls into a single table(). (Hint: Be careful indexing the table - what happens if you make a table of 5 dice rolls? You may need to look to other resources for how to solve this.)

```{r}
#' Function to play dice game using tables
#'
#' @param rolls is a numeric entry for the number of rolls the user specifies
#'
#' @return total amount of money after playing (rules above)
#' @export
#'
#' @examples
play_dice3 <- function(rolls){
  total_rolls <- c(sample(1:6, rolls, replace = TRUE))
  total_rolls <- factor(total_rolls, levels = c(1:6))
  total_rolls <- table(total_rolls)
  total <- -2*(rolls)
  for (i in 1:6){
      if((total_rolls[i]) != 0 & i %% 2 == 1){
        total = total - (i*total_rolls[i])
      }
      if ((total_rolls[i]) != 0 & i %% 2 == 0){
        total = total + (i*total_rolls[i])
      }
  }
  return(as.numeric(total))
        
}
```

Above is the same dice game using tables. I use the same rules as indicated above to choose how I alter the total for the function to return.

iv\) Version 4: Implement this game by using one the "apply" functions.

```{r}
#' Dice Game using sapply function to implement the game.
#'
#' @param rolls is a numeric entry for the number of rolls the user specifies
#'
#' @return total amount the user has won or lost in dice game(rules specified above)
#' @export
#'
#' @examples
play_dice4 <- function(rolls){
  dice_rolls <- list(sample(1:6, rolls, replace = TRUE))
  total_rolls <- sapply(dice_rolls, function(x){
    for (i in 1:6){
      if(x[i] %in% c(1,3,5)){
        x[i] = -x[i]
      }
    }
    return(x)
  }
    )
  total <- (sum(total_rolls) - (2*rolls))
  return(total)
}
```

### Part B: Demonstrate that all versions work. Do so by running each a few times, once with an input of 3, and once with an input of 3000.

Below is the output when running the play_dice1() function:

```{r}
play_dice1(3)
play_dice1(3000)
```

Below is the output when running the play_dice2() function:

```{r}
play_dice2(3)
play_dice2(3000)
```

Below is the output when running the play_dice3() function:

```{r}
play_dice3(3)
play_dice3(3000)
```

Below is the output when running the play_dice4() function:

```{r}
play_dice4(3)
play_dice4(3000)
```

### Part C: Demonstrate that the four versions give the same result. Test with inputs 3 and 3000. (You may need to add a way to control the randomization)

### Part D: Use the *microbenchmark* package to clearly demonstrate the speed of the implementations. Compare performance with a low input (100) and a large input (10000). Discuss the results.

# Problem 2 - Linear Regression

Download the cars data set. The goal is to examine the relationship between horsepower and highway gas mileage.

Download cars data set using ready_csv():

```{r}
library(tidyverse)
```

```{r}
cars <- read_csv('/Users/19892/OneDrive/Documents/STATS506/ProblemSets/ProblemSet2-HT2.0/cars.csv')
```

```{r}
cars[1:10,]
```

Above we can see that the names of the variables are very long.

### Part A: Rename the columns of the data to more reasonable lengths

```{r}
col_names <- c('Height', 'Length', 'Width', 'Driveline', 'EngineType', 'Hybrid', 'NumForwardGears', 'Transmission', 'CityMPG', 'FuelType', 'HighwayMPG', 'Classification', 'ID', 'Make', 'ModelYear', 'Year', 'HP', 'Torque')
colnames(cars) = col_names
cars[1:10,]
```

Above is the cars data frame renamed using the column names I specified in the col_names variable.

### Part B: Restrict the data whose Fuel Type is "Gasoline"

I will do this using the which() function below:

```{r}
cars_gasoline <- cars[which(cars$FuelType == "Gasoline"),]
cars_gasoline[1:10,]
```

Now we have data frame cars_gasoline which restricts the data to cars whose Fuel Type is "Gasoline".

### Part C: Fit a linear regression model predicting MPG on the highway. The predictor of interest is horsepower. Control for:

-   The torque of the engine

-   All three dimensions of the car

-   The year the measurement was made, as a categorical variable. (Not the year the car was manufactured).

Briefly discuss the estimated relationship between horsepower and highway MPG. Be precise about the interpretation of the estimated coefficient.

Here is he linear model predicting MPG on the highway with horsepower:

```{r}
lmod <- lm(HighwayMPG ~ HP + Torque + Height + Length + Width + as.factor(Year), data = cars_gasoline)
summary(lmod)
```

Above we can see that the relationship between horsepower and highway MPG is that with a one unit increase in horsepower, highway MPG increases by about 0.016. This is significant given the p-value in the summary above is below 0.05.

### Part D:

It seems reasonable that there may be an interaction between horsepower and torque. Refit the model (with lm) and generate an interaction plot, showing how the relationship between horsepower and MPG changes as torque changes. Choose reasonable values of horsepower, and show lines for three different reasonable values of torque.

```{r}
library(interactions)
```

```{r}
mod2 <- lm(HighwayMPG ~  HP*Torque + Height + Length + Width + as.factor(Year), data = cars_gasoline)
interact_plot(mod2, pred = HP, at = (Year = 2010), modx = Torque)
```

In the above interaction plot, we can observe that when torque is higher, the relationship between HP and HighwayMPG is a stronger positive relationship than when torque is lower (dotted lighter blue line). When torque is lower (one SD below the mean), this is almost no relationship between HP and HighwayMPG,

### \*Part E

Calculate B-Hat manually (without using lm) by first creating a proper design matrix, then using matrix algebra to estimate B. Confirm that you get the same result as lm did prior.

(not doing this right)

```{r}
library(matlib)
```

```{r}
design_matrix <- model.matrix(lmod, data = cars_gasoline)
estimation <- inv(t(design_matrix) %*% design_matrix) %*% t(design_matrix)
```

# Problem 3 (Stata)
